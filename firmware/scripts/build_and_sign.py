#!/usr/bin/env python3
"""
Build and sign a firmware release.

Usage:
  python3 scripts/build_and_sign.py --env esp32s3_feather_breadboard \
      --priv ~/.ocho-keys/ocho-labs-release-2025.key \
      --pub  ~/.ocho-keys/ocho-labs-release-2025.pub

Outputs into the PlatformIO build dir:
  - firmware.json (augmented with public key fingerprint)
  - firmware.sig  (detached signature over the .bin)
"""
import argparse
import base64
import hashlib
import json
import os
import shlex
import subprocess
import sys
import time

def run(cmd, cwd=None):
    print("$", cmd)
    res = subprocess.run(cmd, cwd=cwd, shell=True)
    if res.returncode != 0:
        sys.exit(res.returncode)

def check_file(path, desc):
    if not os.path.isfile(path):
        print(f"ERROR: {desc} not found: {path}")
        sys.exit(2)

def detect_build_dir(env_name):
    return os.path.join(".pio", "build", env_name)

def find_first_bin(build_dir):
    for fn in os.listdir(build_dir):
        if fn.endswith('.bin'):
            return os.path.join(build_dir, fn)
    return None

def pubkey_der_and_fingerprint(pub_pem_path):
    # Convert PEM -> DER
    der = subprocess.check_output(
        ["openssl", "pkey", "-pubin", "-in", pub_pem_path, "-outform", "DER"]
    )
    b64 = base64.b64encode(der).decode()
    fp = hashlib.sha256(der).hexdigest()
    return b64, fp

def sign_binary(priv_key_path, bin_path, sig_path):
    run(f"openssl pkeyutl -sign -inkey {shlex.quote(priv_key_path)} -in {shlex.quote(bin_path)} -out {shlex.quote(sig_path)}")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--env', default='esp32s3_feather_breadboard')
    ap.add_argument('--priv', default=os.path.expanduser('~/.ocho-keys/ocho-labs-release-2025.key'))
    ap.add_argument('--pub',  default=os.path.expanduser('~/.ocho-keys/ocho-labs-release-2025.pub'))
    args = ap.parse_args()

    # Build
    run(f"pio run -e {shlex.quote(args.env)}")

    build_dir = detect_build_dir(args.env)
    bin_path = find_first_bin(build_dir)
    if not bin_path:
        print("ERROR: No .bin produced in", build_dir)
        sys.exit(3)

    # Manifest path (generated by post script)
    manifest_path = os.path.join(build_dir, 'firmware.json')
    if not os.path.isfile(manifest_path):
        # Create a minimal manifest if post script was not run
        manifest = {
            "name": os.environ.get("IZOD_FW_NAME", "iZod Mini"),
            "version": os.environ.get("IZOD_FW_VERSION", "0.1.0"),
            "build_date": time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime()),
            "environment": args.env,
            "binary": os.path.basename(bin_path)
        }
    else:
        with open(manifest_path, 'r') as f:
            manifest = json.load(f)

    # Add public key info
    check_file(args.pub, 'Public key (.pub)')
    der_b64, fp = pubkey_der_and_fingerprint(args.pub)
    manifest['public_key_der_base64'] = der_b64
    manifest['public_key_sha256'] = fp
    with open(manifest_path, 'w') as f:
        json.dump(manifest, f, indent=2)
    print('Updated manifest with public key:', manifest_path)

    # Sign
    check_file(args.priv, 'Private key (.key)')
    sig_path = os.path.join(build_dir, 'firmware.sig')
    sign_binary(args.priv, bin_path, sig_path)
    print('Created signature:', sig_path)

    # Verify
    rc = subprocess.run([
        'openssl','pkeyutl','-verify','-pubin','-inkey',args.pub,
        '-sigfile',sig_path,'-in',bin_path
    ]).returncode
    if rc == 0:
        print('Signature verification OK')
    else:
        print('WARNING: Local signature verification failed')

if __name__ == '__main__':
    main()


